<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>03_デジタル時計</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }

      canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/",
          "stats": "https://cdn.skypack.dev/stats.js.fps",
          "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.20/+esm"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { FontLoader } from 'three/addons/loaders/FontLoader.js';
      import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
      import Stats from 'stats';
      import GUI from 'lil-gui';

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x333333);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight);
      camera.position.z = 5;
      scene.add(camera);

      /* デバッグツール
      ------------------ */
      //AxesHelper
      // const axesHelper = new THREE.AxesHelper(2);
      // scene.add(axesHelper);

      //CameraHelper
      // const cameraHelper = new THREE.CameraHelper(camera);
      // scene.add(cameraHelper);

      //GridHelper;
      // const gridHelper = new THREE.GridHelper(200, 10);
      // scene.add(gridHelper);

      //Stats
      const stats = new Stats();
      stats.showPanel(0);
      document.body.appendChild(stats.dom);

      //GUI
      const gui = new GUI();

      /* ライトの設定
      ------------------ */
      //環境光
      const ambientLight = new THREE.AmbientLight(0xffffff, 0);
      scene.add(ambientLight);

      const guiAmbient = gui.addFolder('周囲光');
      guiAmbient.addColor(ambientLight, 'color').name('色');
      guiAmbient.add(ambientLight, 'intensity', 0, 5).name('明るさ');

      //環境光のヘルパーは無い
      // const ambientLightHelper = new THREE.AmbientLightHelper(ambientLight);
      // scene.add(ambientLightHelper);

      //平行光
      const directionalLight = new THREE.DirectionalLight(0xff0000, 0);
      directionalLight.position.set(1, 1, 2);
      scene.add(directionalLight);

      const guiDirectional = gui.addFolder('平行光');
      guiDirectional.addColor(directionalLight, 'color').name('色');
      guiDirectional.add(directionalLight, 'intensity', 0, 5).name('明るさ');

      // 平行光のヘルパー
      // const directionalLightHelper = new THREE.DirectionalLightHelper(directionalLight);
      // scene.add(directionalLightHelper);

      //半球光
      const hemisphereLight = new THREE.HemisphereLight(0x00ffff, 0xffff00, 3);
      scene.add(hemisphereLight);

      const guiHemisphere = gui.addFolder('半球光');
      guiHemisphere.addColor(hemisphereLight, 'color').name('空の色');
      guiHemisphere.addColor(hemisphereLight, 'groundColor').name('地面の色');
      guiHemisphere.add(hemisphereLight, 'intensity', 0, 5).name('明るさ');

      // 半球光のヘルパー
      // const hemisphereLightHelper = new THREE.HemisphereLightHelper(hemisphereLight);
      // scene.add(hemisphereLightHelper);

      /* テキストの表示
      ------------------ */
      const group = new THREE.Group();
      scene.add(group);

      //フォントの読み込み
      const fontLoader = new FontLoader();

      let text = null;
      let textGeometry = null;
      const material = new THREE.MeshStandardMaterial({ color: 0xffffff });

      const leftFillNum = (num) => {
        return num.toString().padStart(2, '0');
      };

      const drawTime = (font) => {
        group.remove(text);
        if (textGeometry) {
          textGeometry.dispose();
        }

        const now = new Date();
        const hour = leftFillNum(now.getHours());
        const minute = leftFillNum(now.getMinutes());
        const second = leftFillNum(now.getSeconds());
        const milliSecond = now.getMilliseconds();
        const currentTime = `${hour}:${minute}:${second}`;

        textGeometry = new TextGeometry(currentTime, {
          font: font,
          size: 1,
          depth: 0.5,
          bevelEnabled: true,
          bevelThickness: 0.03,
          bevelSize: 0.02,
          bevelOffset: 0,
          bevelSegments: 5,
        });
        textGeometry.center();

        text = new THREE.Mesh(textGeometry, material);
        group.add(text);

        setTimeout(drawTime, 1000 - milliSecond, font);
      };

      fontLoader.load('./font/Roboto_Regular.json', (font) => {
        setTimeout(drawTime, 10, font);
      });

      //オブジェクト追加
      for (let i = 0; i < 100; i++) {
        const box = new THREE.Mesh(new THREE.BoxGeometry(), material);

        box.position.x = (Math.random() - 0.5) * 10;
        box.position.y = (Math.random() - 0.5) * 10;
        box.position.z = (Math.random() - 0.5) * 10;
        box.rotation.x = Math.random() * Math.PI;
        box.rotation.y = Math.random() * Math.PI;
        const scale = Math.random();
        box.scale.set(scale, scale, scale);
        group.add(box);
      }

      //レンダラー
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      renderer.render(scene, camera);

      //コントロール
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      //更新
      const clock = new THREE.Clock();

      const update = () => {
        stats.begin();
        renderer.render(scene, camera);
        controls.update();

        const elapsedTime = clock.getElapsedTime();
        group.rotation.y = elapsedTime * 0.2;
        group.rotation.x = elapsedTime * 0.2;
        group.rotation.z = elapsedTime * 0.2;

        stats.end();
        window.requestAnimationFrame(update);
      };

      update();

      //ウィンドウリサイズ
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
